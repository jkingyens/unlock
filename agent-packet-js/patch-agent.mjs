import fs from 'fs/promises';
import path from 'path';

async function patchAgent() {
    const agentPath = path.join('dist', 'agent.js');
    let code = await fs.readFile(agentPath, 'utf8');

    console.log("Patching JCO shim for JSPI...");

    const hostFunctions = ['log', 'registerTask', 'updateTask', 'notifyPlayer', 'getCurrentUrl', 'ask']; // Added 'ask' for legacy

    for (const func of hostFunctions) {
        // Regex to find the trampoline function that calls func(...)
        // "function trampolineXX(...) { ... func(...) ... }"
        // We look for "func(" inside the body.
        // Simplified regex: find function definition, capturing name and args, then ensure body contains func(
        // Note: This assumes only one trampoline calls the function, or matches the first one.
        // We'll search globally? No, file is big.

        // We'll scan the file for "function trampolineXX" blocks?
        // Easier: Regex for `function\s+(trampoline\d+)\(([^)]+)\)\s*\{[^}]*\b${func}\(`
        const trampolineRegex = new RegExp(`function\\s+(trampoline\\d+)\\(([^)]+)\\)\\s*\\{[^}]*\\b${func}\\(`, 's');
        const match = code.match(trampolineRegex);

        if (match) {
            const trampolineName = match[1];
            const args = match[2];
            console.log(`  - Found trampoline for '${func}': ${trampolineName}`);

            // 1. Make the trampoline async
            const decl = `function ${trampolineName}(${args}) {`;
            const asyncDecl = `async ${decl}`;

            if (code.includes(asyncDecl)) {
                console.log(`    * ${trampolineName} is already async.`);
            } else {
                code = code.replace(decl, asyncDecl);
                console.log(`    * Made ${trampolineName} async`);
            }

            // 2. Await the function call
            // Pattern: "func(" -> "await func("
            // But be careful not to double await: "await await func("
            // Regex: `(?<!await\s)\b${func}\(`
            // JS lookbehind support is good in Node.
            const callRegex = new RegExp(`(?<!await\\s)\\b${func}\\(`, 'g');
            if (code.match(callRegex)) {
                code = code.replace(callRegex, `await ${func}(`);
                console.log(`    * Added await to ${func}() call(s)`);
            } else {
                console.log(`    * ${func}() calls already awaited.`);
            }

            // 3. Wrap trampoline in Suspending in the imports table
            // Match: "'36': trampoline61,"
            // We want: "'36': new WebAssembly.Suspending(trampoline61),"
            // But check if already wrapped?
            const importRegex = new RegExp(`'\\d+':\\s*${trampolineName},`, 'g');
            // If already wrapped: "'36': new WebAssembly.Suspending(trampoline61)," will not match the above regex if we match exact strings?
            // Wait, regex `'\\d+':\\s*trampoline61,` matches `..., '36': trampoline61, ...`
            // It does NOT match `'36': new WebAssembly.Suspending(trampoline61),` because of extra text.
            // So if it matches, it's UNWRAPPED.

            let wrappedCount = 0;
            code = code.replace(importRegex, (m) => {
                wrappedCount++;
                return m.replace(trampolineName, `new WebAssembly.Suspending(${trampolineName})`);
            });
            if (wrappedCount > 0) {
                console.log(`    * Wrapped ${trampolineName} in Suspending (count: ${wrappedCount})`);
            } else {
                console.log(`    * ${trampolineName} usage in imports not found or already wrapped.`);
            }

        } else {
            // console.log(`  - Trampoline for '${func}' not found.`);
        }
    }

    // 4. Wrap the internal Wasm export 'run' (originally generated by JCO)
    // JCO pattern variable renaming might vary.
    // We look for assignment: "exports1Run = exports1.run;" (Old)
    // Now it might be "exports1Run = exports1.run;" or just "exports1.run" usage.
    // Wait, if export name is 'run', generated code uses 'run' variable?

    // Pattern search: `run = exports1.run;` OR `exports1Run = exports1.run;`
    // We'll look for ` = exports1.run;`

    // We need to Find what variable holds `exports1.run`.
    const exportAssignRegex = /([a-zA-Z0-9_$]+)\s*=\s*exports1\.run;/;
    const exportMatch = code.match(exportAssignRegex);

    if (exportMatch) {
        const varName = exportMatch[1];
        console.log(`  - Found internal export variable: ${varName}`);
        code = code.replace(
            `${varName} = exports1.run;`,
            `${varName} = WebAssembly.promising(exports1.run);`
        );
        console.log(`  - Wrapped ${varName} in WebAssembly.promising`);

        // 5. Find the wrapper function that calls this variable
        // It should be `function run(arg0) { ... ret = varName(arg0 ...); ... }`
        // We search for the call site
        // "const ret = varName("
        const callRegex = new RegExp(`const ret = ${varName}\\(`);
        if (code.match(callRegex)) {
            code = code.replace(
                callRegex,
                `const ret = await ${varName}(`
            );
            console.log(`  - Added await to internal call of ${varName}`);

            // 6. Make the wrapper function async
            // We need to find the function containing this call.
            // It is likely the export function 'run'.
            // "function run(arg0) {"
            if (code.includes('function run(arg0) {')) {
                code = code.replace('function run(arg0) {', 'async function run(arg0) {');
                console.log("  - Made wrapper function 'run' async");
            } else {
                console.warn("  ! Wrapper function 'run' signature mismatch or not found.");
            }
        } else {
            console.warn(`  ! Usage of ${varName} not found.`);
        }

    } else {
        console.warn("  ! Internal export assignment for 'run' not found.");
    }

    await fs.writeFile(agentPath, code);
    console.log("Patch complete.");
}

patchAgent().catch(console.error);