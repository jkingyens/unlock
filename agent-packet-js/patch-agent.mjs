import fs from 'fs/promises';
import path from 'path';

async function patchAgent() {
    const agentPath = path.join('dist', 'agent.js');
    let code = await fs.readFile(agentPath, 'utf8');

    console.log("Patching JCO shim for JSPI...");

    // Regex to find the trampoline function that calls ask(result0)
    const trampolineRegex = /function\s+(trampoline\d+)\(([^)]+)\)\s*\{[^}]*ask\(result0\)[^}]*\}/s;
    const match = code.match(trampolineRegex);

    if (match) {
        const funcName = match[1];
        const args = match[2];
        console.log(`  - Found trampoline function: ${funcName}`);

        // 1. Make the trampoline async
        code = code.replace(
            `function ${funcName}(${args}) {`,
            `async function ${funcName}(${args}) {`
        );
        console.log(`  - Made ${funcName} async`);

        // 2. Await the ask() call
        code = code.replace(
            'const ret = ask(result0);',
            'const ret = await ask(result0);'
        );
        console.log("  - Added await to ask()");

        // 3. Wrap trampoline in Suspending
        const importRegex = new RegExp(`'\\d+':\\s*${funcName},`, 'g');
        code = code.replace(importRegex, (m) => {
            return m.replace(funcName, `new WebAssembly.Suspending(${funcName})`);
        });
        console.log(`  - Wrapped ${funcName} in Suspending`);
    } else {
        console.warn("  ! Trampoline function for 'ask' not found.");
    }

    // 4. Wrap the internal Wasm export 'run' (originally generated by JCO)
    // JCO pattern variable renaming might vary.
    // We look for assignment: "exports1Run = exports1.run;" (Old)
    // Now it might be "exports1Run = exports1.run;" or just "exports1.run" usage.
    // Wait, if export name is 'run', generated code uses 'run' variable?

    // Pattern search: `run = exports1.run;` OR `exports1Run = exports1.run;`
    // We'll look for ` = exports1.run;`

    // We need to Find what variable holds `exports1.run`.
    const exportAssignRegex = /([a-zA-Z0-9_$]+)\s*=\s*exports1\.run;/;
    const exportMatch = code.match(exportAssignRegex);

    if (exportMatch) {
        const varName = exportMatch[1];
        console.log(`  - Found internal export variable: ${varName}`);
        code = code.replace(
            `${varName} = exports1.run;`,
            `${varName} = WebAssembly.promising(exports1.run);`
        );
        console.log(`  - Wrapped ${varName} in WebAssembly.promising`);

        // 5. Find the wrapper function that calls this variable
        // It should be `function run(arg0) { ... ret = varName(arg0 ...); ... }`
        // We search for the call site
        // "const ret = varName("
        const callRegex = new RegExp(`const ret = ${varName}\\(`);
        if (code.match(callRegex)) {
            code = code.replace(
                callRegex,
                `const ret = await ${varName}(`
            );
            console.log(`  - Added await to internal call of ${varName}`);

            // 6. Make the wrapper function async
            // We need to find the function containing this call.
            // It is likely the export function 'run'.
            // "function run(arg0) {"
            if (code.includes('function run(arg0) {')) {
                code = code.replace('function run(arg0) {', 'async function run(arg0) {');
                console.log("  - Made wrapper function 'run' async");
            } else {
                console.warn("  ! Wrapper function 'run' signature mismatch or not found.");
            }
        } else {
            console.warn(`  ! Usage of ${varName} not found.`);
        }

    } else {
        console.warn("  ! Internal export assignment for 'run' not found.");
    }

    await fs.writeFile(agentPath, code);
    console.log("Patch complete.");
}

patchAgent().catch(console.error);