// ext/background-modules/packet-processor.js
// Manages the runtime lifecycle of packet instances, including instantiation, deletion, and publishing.

import {
    logger,
    storage,
    indexedDbStorage,
    arrayBufferToBase64,
    base64Decode,
    sanitizeForFileName,
} from '../utils.js';
import cloudStorage from '../cloud-storage.js';
import * as tabGroupHandler from './tab-group-handler.js';
import * as ruleManager from './rule-manager.js';

// --- Helper to send progress notifications ---
function sendProgressNotification(action, data) {
    chrome.runtime.sendMessage({ action: action, data: data })
      .catch(err => {
           if (err && err.message && !err.message.includes("Receiving end does not exist") && !err.message.includes("Could not establish connection")) {
               logger.warn('PacketProcessor:sendProgress', `Could not send ${action} message`, err);
           }
      });
}

function sendStencilProgressNotification(imageId, step, status, text, progressPercent, title = null) {
    const data = {
        imageId: imageId,
        step: step,
        status: status,
        text: text,
        progressPercent: progressPercent
    };
    if (title) {
        data.title = title;
    }
    const message = {
        action: 'packet_creation_progress',
        data: data
    };
    chrome.runtime.sendMessage(message).catch(err => {
        if (err && err.message && !err.message.includes("Receiving end does not exist") && !err.message.includes("Could not establish connection")) {
            logger.warn('PacketProcessor:sendStencilProgress', `Could not send progress for ${imageId}. Error: ${err.message}`, { messageData: message.data });
        }
    });
}

function sendInstantiationProgress(instanceId, progress, text, title) {
    const data = {
        instanceId: instanceId,
        progressPercent: progress,
        text: text,
        title: title
    };
    sendProgressNotification('packet_instantiation_progress', data);
}


// --- Main Processing Functions ---

export async function instantiatePacket(imageId, preGeneratedInstanceId, initiatorTabId = null) {
    const instanceId = preGeneratedInstanceId; // Use the ID generated by the UI
    const successfullyUploadedFiles = [];
    logger.log('PacketProcessor:instantiatePacket', 'Starting INSTANCE creation', { imageId, instanceId });

    try {
        let packetImage = await storage.getPacketImage(imageId);
        if (!packetImage) throw new Error(`Packet Image ${imageId} not found.`);

        sendInstantiationProgress(instanceId, 5, "Preparing...", packetImage.title);

        const internalContentToUpload = packetImage.sourceContent.filter(item => item.origin === 'internal');
        const totalFilesToUpload = internalContentToUpload.length;
        let filesUploaded = 0;
        let activeCloudConfig = null;

        if (totalFilesToUpload > 0) {
            activeCloudConfig = await storage.getActiveCloudStorageConfig();
            if (!activeCloudConfig) throw new Error("This packet requires content to be published, but no active cloud storage is configured.");
            if (!(await cloudStorage.initialize())) throw new Error("Cloud storage failed to initialize for publishing.");
        }

        sendInstantiationProgress(instanceId, 10, "Configuration checked", packetImage.title);

        // Create a deep copy of the content that we can safely modify.
        const packetInstanceContents = JSON.parse(JSON.stringify(packetImage.sourceContent));
        
        for (const item of packetInstanceContents) {
            if (item.origin === 'internal') {
                const lrl = item.lrl;
                if (!lrl) continue;
                
                const indexedDbKey = sanitizeForFileName(lrl);
                const storedContent = await indexedDbStorage.getGeneratedContent(imageId, indexedDbKey);
                
                if (!storedContent || !storedContent[0]?.content) {
                    throw new Error(`Cannot instantiate: Content for ${lrl} is missing from IndexedDB for image ${imageId}.`);
                }

                const contentToUpload = storedContent[0].content;
                const contentType = item.contentType || item.mimeType;
                const cloudPath = `packets/${instanceId}${lrl.startsWith('/') ? lrl : '/' + lrl}`;

                const uploadResult = await cloudStorage.uploadFile(cloudPath, contentToUpload, contentType, 'private');
                
                if (uploadResult.success) {
                    filesUploaded++;
                    const progress = 10 + Math.round((filesUploaded / totalFilesToUpload) * 85);
                    sendInstantiationProgress(instanceId, progress, `Uploading ${filesUploaded}/${totalFilesToUpload}...`, packetImage.title);

                    successfullyUploadedFiles.push(uploadResult.fileName);
                    item.url = uploadResult.fileName; 
                    item.published = true;
                    item.publishContext = {
                        storageConfigId: activeCloudConfig.id,
                        provider: activeCloudConfig.provider,
                        region: activeCloudConfig.region,
                        bucket: activeCloudConfig.bucket
                    };

                } else {
                    throw new Error(`Failed to publish ${lrl}: ${uploadResult.error}`);
                }
            }
        }

        // --- START: Pruning Logic ---
        // Create sets of all valid URLs and LRLs that exist in the final instance content.
        const validUrls = new Set(packetInstanceContents.map(item => item.url).filter(Boolean));
        const validLrls = new Set(packetInstanceContents.map(item => item.lrl).filter(Boolean));

        // Filter the moments from the original image to only include those whose source content exists in this instance.
        const filteredMoments = (packetImage.moments || []).filter(moment => {
            return validLrls.has(moment.sourceUrl);
        });

        // Filter the checkpoints to only include those where all required items are present in this instance.
        const filteredCheckpoints = (packetImage.checkpoints || []).filter(checkpoint => {
            return checkpoint.requiredItems.every(item => validUrls.has(item.url));
        });
        // --- END: Pruning Logic ---

        const packetInstance = {
            instanceId: instanceId,
            imageId: imageId,
            title: packetImage.title,
            created: packetImage.created,
            instantiated: new Date().toISOString(),
            contents: packetInstanceContents,
            visitedUrls: [],
            moments: filteredMoments,
            momentsTripped: Array(filteredMoments.length).fill(0),
            checkpoints: filteredCheckpoints,
            checkpointsTripped: Array(filteredCheckpoints.length).fill(0)
        };

        await storage.savePacketInstance(packetInstance);
        await storage.savePacketBrowserState({ instanceId: instanceId, tabGroupId: null, activeTabIds: [], lastActiveUrl: null });
        await ruleManager.addOrUpdatePacketRules(packetInstance);
        
        sendInstantiationProgress(instanceId, 100, "Complete", packetImage.title);
        logger.log('PacketProcessor:instantiatePacket', 'Final Packet Instance and BrowserState saved.', { instanceId });

        return { success: true, instanceId: instanceId, instance: packetInstance };

    } catch (error) {
        logger.error('PacketProcessor:instantiatePacket', 'Error during instantiation/publishing', { imageId, instanceId, error });
        sendProgressNotification('packet_creation_failed', { instanceId: instanceId, error: error.message });

        if (successfullyUploadedFiles.length > 0) {
            logger.warn('PacketProcessor:instantiatePacket', `Rolling back ${successfullyUploadedFiles.length} uploaded files.`);
            for (const fileUrl of successfullyUploadedFiles) {
                await cloudStorage.deleteFile(fileUrl).catch(e => logger.error('PacketProcessor:instantiatePacket', `Rollback delete failed: ${fileUrl}`, e));
            }
        }
        
        await ruleManager.removePacketRules(instanceId);
        return { success: false, error: error.message || 'Unknown instantiation error' };
    }
}

export async function processDeletePacketsRequest(data, initiatorTabId = null) {
    const { packetIds } = data;
    if (!Array.isArray(packetIds) || packetIds.length === 0) {
        return { success: false, error: "No packet IDs provided for deletion." };
    }
    logger.log('PacketProcessor:processDeletePacketsRequest', 'Processing delete request for packets:', packetIds);
    let deletedCount = 0;
    let errors = [];

    for (const instanceId of packetIds) {
        try {
            const instance = await storage.getPacketInstance(instanceId);
            if (!instance) {
                logger.warn('PacketProcessor:delete', `Packet instance ${instanceId} not found for deletion.`);
                await storage.deletePacketBrowserState(instanceId).catch(e => logger.warn('PacketProcessor:delete', `Error deleting orphaned browser state for ${instanceId}`, e));
                await ruleManager.removePacketRules(instanceId);
                continue;
            }

            const browserState = await storage.getPacketBrowserState(instanceId);

            if (browserState?.tabGroupId) {
                logger.log('PacketProcessor:delete', `Packet ${instanceId} has tab group ${browserState.tabGroupId}. Requesting removal.`);
                await tabGroupHandler.handleRemoveTabGroups({ groupIds: [browserState.tabGroupId] }, () => {});
            }
            
            await storage.deletePacketBrowserState(instanceId);

            if (await cloudStorage.initialize()) {
                for (const item of instance.contents) {
                    if (item.origin === 'internal' && item.published && item.url) {
                        await cloudStorage.deleteFile(item.url)
                            .catch(e => logger.warn('PacketProcessor:delete', `Error deleting cloud file ${item.url}`, e));
                    }
                }
            } else {
                logger.warn('PacketProcessor:delete', `Cloud storage not initialized, cannot delete cloud files for instance ${instanceId}.`);
            }
            
            await storage.deletePacketInstance(instanceId);
            logger.log('PacketProcessor:delete', `Deleted PacketInstance: ${instanceId}`);

            await ruleManager.removePacketRules(instanceId);
            logger.log('PacketProcessor:delete', `Removed redirect rules for: ${instanceId}`);

            sendProgressNotification('packet_instance_deleted', { packetId: instanceId, source: 'user_action' });
            
            deletedCount++;
        } catch (error) {
            logger.error('PacketProcessor:delete', `Error deleting packet ${instanceId}`, error);
            errors.push({ instanceId, error: error.message });
        }
    }

    const result = {
        success: errors.length === 0,
        deletedCount: deletedCount,
        totalRequested: packetIds.length,
        errors: errors,
        message: errors.length > 0 ? `${deletedCount} deleted, ${errors.length} failed.` : `${deletedCount} packet(s) deleted successfully.`
    };
    sendProgressNotification('packet_deletion_complete', result);
    return result;
}

export async function processDeletePacketImageRequest(data) {
    const { imageId } = data;
    if (!imageId) {
        return { success: false, error: "Image ID is required for deletion." };
    }
    logger.log('PacketProcessor:processDeletePacketImage', 'Processing delete request for image:', imageId);
    let errors = [];

    try {
        await storage.deletePacketImage(imageId);
        logger.log('PacketProcessor:deleteImage', `Deleted PacketImage: ${imageId}`);
    } catch (error) {
        logger.error('PacketProcessor:deleteImage', `Error deleting packet image ${imageId}`, error);
        errors.push(error.message);
    }

    try {
        await indexedDbStorage.deleteGeneratedContentForImage(imageId);
        logger.log('PacketProcessor:deleteImage', `Deleted IndexedDB content for: ${imageId}`);
    } catch (error) {
        logger.error('PacketProcessor:deleteImage', `Error deleting IDB content for image ${imageId}`, error);
        errors.push(error.message);
    }
    
    sendProgressNotification('packet_image_deleted', { imageId: imageId });
    
    return {
        success: errors.length === 0,
        errors: errors
    };
}

export async function importImageFromUrl(url) {
    if (!url) return { success: false, error: "URL is required for import." };

    const newImageId = `img_${Date.now()}_imported_${Math.random().toString(36).substring(2, 9)}`;

    try {
        sendStencilProgressNotification(newImageId, 'init', 'active', 'Downloading...', 10, 'Importing Packet...');

        const response = await fetch(url, { cache: 'no-store' });
        if (!response.ok) throw new Error(`Failed to download packet from URL (${response.status})`);
        const sharedImage = await response.json();

        if (!sharedImage || !sharedImage.title || !Array.isArray(sharedImage.sourceContent)) {
            throw new Error("Invalid packet image format in downloaded JSON.");
        }
        
        const importedPacketImage = { ...sharedImage, id: newImageId, created: new Date().toISOString(), shareUrl: url };
        
        for (const contentItem of importedPacketImage.sourceContent) {
            if (contentItem.origin === 'internal' && contentItem.contentB64) {
                const contentBuffer = base64Decode(contentItem.contentB64);
                const indexedDbKey = sanitizeForFileName(contentItem.lrl);
                
                await indexedDbStorage.saveGeneratedContent(newImageId, indexedDbKey, [{
                    name: contentItem.lrl.split('/').pop(),
                    content: contentBuffer,
                    contentType: contentItem.contentType || contentItem.mimeType
                }]);

                delete contentItem.contentB64;
            }
        }

        await storage.savePacketImage(importedPacketImage);
        logger.log('PacketProcessor:importImageFromUrl', 'Packet image imported and content stored in IndexedDB.', { newImageId, originalUrl: url });
        
        sendStencilProgressNotification(newImageId, 'complete', 'completed', 'Ready in Library', 100);
        sendProgressNotification('packet_image_created', { image: importedPacketImage });

        return { success: true, imageId: newImageId };

    } catch (error) {
        logger.error('PacketProcessor:importImageFromUrl', 'Error importing image', { url, error });
        sendProgressNotification('packet_creation_failed', { imageId: newImageId, error: error.message, step: 'import_failure' });
        return { success: false, error: error.message };
    }
}

export async function publishImageForSharing(imageId) {
    if (!imageId) return { success: false, error: "Image ID is required for sharing." };
    if (!(await cloudStorage.initialize())) {
        return { success: false, error: "Cloud storage not initialized. Cannot share." };
    }

    try {
        const packetImage = await storage.getPacketImage(imageId);
        if (!packetImage) return { success: false, error: `Packet image ${imageId} not found.` };
        
        const imageForExport = JSON.parse(JSON.stringify(packetImage));

        for (const contentItem of imageForExport.sourceContent) {
            if (contentItem.origin === 'internal' && contentItem.lrl) {
                const indexedDbKey = sanitizeForFileName(contentItem.lrl);
                const storedContent = await indexedDbStorage.getGeneratedContent(imageId, indexedDbKey);
                
                if (storedContent && storedContent[0]?.content) {
                    contentItem.contentB64 = arrayBufferToBase64(storedContent[0].content);
                } else {
                    logger.warn('PacketProcessor:publishImage', `Content for ${contentItem.lrl} not found in IndexedDB for image ${imageId}. It will not be included in the export.`);
                }
            }
        }

        const jsonString = JSON.stringify(imageForExport);
        const shareFileName = `shared/img_${imageId.replace(/^img_/, '')}_${Date.now()}.json`;

        const uploadResult = await cloudStorage.uploadFile(shareFileName, jsonString, 'application/json', 'public-read');

        if (uploadResult.success && uploadResult.fileName) {
            const publicUrl = cloudStorage.getPublicUrl(uploadResult.fileName);
            if (!publicUrl) return { success: false, error: "Failed to construct public URL after upload." };
            
            logger.log('PacketProcessor:publishImageForSharing', 'Image published for sharing.', { imageId, shareUrl: publicUrl });
            return { success: true, shareUrl: publicUrl, message: "Packet link ready to share!" };
        } else {
            return { success: false, error: `Failed to upload shareable image: ${uploadResult.error || 'Unknown cloud error'}` };
        }
    } catch (error) {
        logger.error('PacketProcessor:publishImageForSharing', 'Error publishing image', { imageId, error });
        return { success: false, error: error.message || "Unknown error during image sharing." };
    }
}